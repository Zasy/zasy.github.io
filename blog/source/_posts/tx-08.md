1. 零值比较
   - bool: if(ok)
   - int: if(ok == 0)
   - pointer: if(ok == null)
   - float: if(ok <= 1e-5 && ok >= -1e-5)
2. sizeof 和 strlen的不同
   - 运算符 和 标准库函数
   - sizeof 可以运算任何类型的大小 strlen只能得到"\0"结尾的字符串的大小
   - sizeof的大小要提前指定好，因为在编译期间就要确定下来
3. 对象之间的复制(类默认赋值函数)
   - 可以赋值，当存在指针成员变量时，要提前的深拷贝
   - 深拷贝和浅拷贝的区别
4. static的作用
   - 全局静态变量 限制了变量的作用域，只能在本文件中被使用
   - 局部静态变量 由于存储在静态区，延长了变量的使用时间，只有程序结束的时候，该变量的生命周期才结束。
   - 修饰类成员(变量 和 函数) 所有的实例共有
   - 满足函数在不同调用期的通信，满足不同类对象之间的通信-> 单例模式
   - static的默认值是0
5. 结构体和类的区别
   - 结构体的默认访问权限是pubic 类是private
6. malloc 和 new 的区别
   - malloc和free 是标准库函数， new和delete是运算符
   - malloc分配空间后，不能吊起构造函数， free也不能吊起构造函数； new吊起构造函数， delete调起析构函数
   - malloc返回void指针， new返回对应类指针
7. 指针和引用的区别 
   - 引用只是给变量起了一个别名，不占内存空间。 指针是新分配了一个指针的空间
   - 引用声明时必须初始化，指针可以先申明再初始化
   - 引用只能指定一个变量，指针可以先指向一个变量，然后再指向另一个变量
   - 引用必须指向一个变量的实体，指针可以是一个空指针
8. 宏定义和函数的区别
   - 宏定义在预编译时就替换了代码，相当于直接插入了代码，运行时不需要跳转；函数运行需要跳转
   - 宏定义没有类型检查；函数有类型的检查
9. 宏定义和const的区别
   - 宏定义在预编译阶段；const在编译的阶段
   - 宏没有类型检查； const有类型检查
   - 没有分配空间，直接代码插入； const要占据内存空间
10. 宏定义和typedef的区别
    - 宏定义主要用于常量和复杂函数的表示；typedef主要用于类型的别名
    - 编译前替换；typedef还是在编译期间

11.  宏定义和内联函数的区别
    - 内联函数也是函数，在编译期间起作用，也可以做类型检查
    - 具有函数的重载等功能
    - 内联函数可以作为类的成员函数使用类的保护成员和私有成员
12. 数组名和指针的区别
    - 可以将数组名理解为常量指针，所以没有自增和自减的操作
    - 数组名传递给一般指针后就退化了，sizeof就计算不出整个数组的大小

### 面向对象基础

1. 三大特性
   - 封装性
   - 继承性
   - k多态性
   - 模板特性(c++)
2. public/protected/private的区别
   - public ，类的内部和外部都可以访问
   - protected，只有类的内部成员或者派生类中可以访问
   - private， 类的内部成员访问派生类内部不可以访问
3. 对象的存储空间
   - 非静态成员的数据类型大小之和
   - 编译器额外加入的虚函数指针变量，指向虚表，虚表保存的是虚函数的地址的列表
   - 还有一些对齐的padding
4.  空类的大小和有哪些成员函数？
   - 空类的大小为1字节
   - 成员函数有：
     - 构造函数
     - 析构函数
     - 默认拷贝函数
     - 默认赋值函数

5. 构造函数和析构函数必须是基类指针吗？
   - 构造函数
     - 构造函数不能是虚函数，虚函数的作用在于通过子类的指针或引用来调用父类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过子类的指针或者引用去调用。
   - 析构函数
     - 析构函数一般都要为虚函数，
     - 只有当析构函数为虚函数时，delete调一个基类指针的类时，才会调起对应的子类的析构函数
6. 构造函数和析构函数的调用顺序是？
   - 构造函数(从初始化列表的运行顺序可看出)
     - 基类构造函数：多层基类则先构造最上层的基类，依次向外，如果是多继承则从左到右
     - 成员变量的构造函数： 先构造成员变量的构造函数，然后调用本类的构造函数
     - 派生类的构造函数
   - 析构函数
     - 析构顺序与构造顺序相反

7. 拷贝构造函数和赋值运算函数的区别？
   - 拷贝构造函数是函数，赋值运算符是运算符重载。
   - 拷贝构造函数会生成新的对像，赋值运算符不会
   - 在形参传递的时候是调用拷贝构造函数，因为生成了本地的新对象
8. 覆盖、隐藏和重载的区别
   - 重载，在相同的类或作用域下，当函数名相同，参数不同的情况就发生了函数的重载
   - 覆盖，当虚函数在派生类中对虚函数进行了实现的时候，派生类的虚函数地址对原虚函数的地址进行了覆盖
   - 隐藏，派生类本来是集成了基类的成员函数，当派生类又实现了基类函数，而且这个基类成员函数还不是虚函数的情况下，就会把基类成员函数给隐藏，不管参数时候相同。
9. 哪几种情况需要用到初始化列表
   - 初始化const成员
   - 初始化一个reference成员
   - 调用基类的构造函数，并且该函数需要参数
   - 调用数据成员对象的构造函数，而该函数需要参数

### STL(标准模板库)

1. Vector

   ```c++
   定义：
   	vector<T> vec;
   插入元素：
   	vec.push_back(T);
   	vec.insert(iterator, T);
   删除元素：
   	vec.pop_back();
   	vec.erase(iterator);
   修改元素:
   	vec[position] = T;
   遍历容器：
   for(auto it = vec.begin(); it < vec.end(); it++){
   
   }
   其他：
   	vec.empty();
   	vec.size();
   	vec.capacity();
   	vec.begin();
   	vec.end();
   ```

   实现：

   - 线性表，数组实现：
     - 支持随机访问
     - 插入删除操作需要大量的移动元素
   - 需要连续的物理存储空间
   - 当空间不够及 size < capacity 的时候，需要空间拓展*2

   迭代器失效：

   - 插入元素：
     - 尾后插入，当size < capacity时， 首迭代器不失效，其他失效。 

2. map

   实现：

   - 树状结构，插入和删除操作不需要数据的复制，不连续的内存空间
   - 操作复杂度和树的高度相关

   红黑树的基本概念：

   - 红黑树是二叉排序树

     - 左子树的所有元素都比根节点小
     - 右子树所有节点都比根节点大
     - 左右子树也都是二叉排序树

   - 而且还要满足几点要求

     - 树中所有节点非黑即白
     - 根节点必须是黑色
     - 红色节点的子节点必须为黑
     - 从根到NULL的任何路径上黑节点的数量必须相同

   - 查找时间都是O(logn)

   - 红黑树节点的定义

     ```c++
     enum Color {
         red 	= 0;
         black 	= 1;
     };
     struct RBTreeNode{
         struct RBTreeNode* left, *right, *parent;
         int key;
         int data;
         Color col;
     };
     ```

     1. 相对于平衡二叉树，平衡性稍差但是旋转次数会降低
     2. 相对于普通的二叉查找树，平衡性要好，查找效率要高


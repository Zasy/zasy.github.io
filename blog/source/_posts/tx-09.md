---
title: æ•°æ®æœºæ„ä¸ç®—æ³•
date: 2018-10-04 19:08:13
tags: 
- æ•°æ®ç»“æ„
- ç®—æ³•
- leetcode
---

### leetcodeåˆ—è¡¨

| åºå· |         é¢˜ç›®          | ä»£ç  | è§£ç­” |
| :--: | :-------------------: | :--: | :--: |
|  1   | äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹ |  ğŸ˜Š   |  ğŸ˜Š   |
|  2   |    å®ç°LRUå†…å­˜æ¨¡å‹    |  ğŸ˜Š   |  ğŸ˜Š   |
|  3   | å¹¶æŸ¥é›†å®ç°æœ€å°ç”Ÿæˆæ ‘  |  ğŸ˜Š   |  ğŸ˜Š   |
|  4   |     æœ€çŸ­è·¯å¾„ç®—æ³•      |  ğŸ™‚   |  ğŸ™‚   |

è§£ç­”ï¼š

1. äºŒå‰æœç´¢æ ‘çš„ç¬¬Kå¤§èŠ‚ç‚¹

   - è§£ç­”ï¼šäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†æœ‰åºçš„ç‰¹ç‚¹

   - ä»£ç 

     ```c++
     #include <iostream>
     #include <stack>
     
     using namespace std;
     
     int midTravelKthest(TreeNode* root, int k){
         TreeNode* p = root;
         stack<TreeNode*> s;
     	int count = 0;   
         while(p || !s.empty()){
             if(p){
               s.push(p);
               p = p->left;  
             }else{
                 p = s.top();
                 s.pop();
                 count++;
                 if (count == k) {
                     cout << p->val << endl;
                     return;
                 }
                 p = p->right;
             }    
         }
     }
     ```

2. å®ç°LRUå†…å­˜æ¨¡å‹

   - è§£ç­”ï¼š

     - getæ“ä½œï¼Œå…ˆæ£€æŸ¥pos ä¼˜å…ˆçº§seté‡Œé¢æ˜¯å¦æœ‰è¯¥å…ƒç´ ï¼Œå¦‚æœæœ‰åˆ™é‡æ–°putè¯¥k-valueã€‚
     - putæ“ä½œï¼Œå…ˆæ£€æŸ¥å…¶ä¸­posæ˜¯å¦æœ‰è¯¥keyï¼Œå¦‚æœæœ‰ï¼Œåˆ™eraseè¯¥å…ƒç´  é€šè¿‡iteratorï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™æ£€æŸ¥å…ƒç´ çš„ä¸ªæ•°æ˜¯å¦è¾¾åˆ°äº†capacityï¼Œå¦‚æœåˆ°äº†å°±è¦å°†listé˜Ÿå°¾å…ƒç´ eraseæ‰ï¼›æœ€åç»Ÿä¸€çš„åœ¨é˜Ÿåˆ—æœ€å‰é¢æ’å…¥å…ƒç´ ï¼Œå¹¶åœ¨posä¸­è®°å½•å…¶ä½ç½®

   - ä»£ç ï¼š

     ```c++
     class LRU {
     public:
         LRU : capacity(int ca){}
     
         int Get(int key){
             if(pos.find(key) != pos.end()){
                 Put(key, recent[pos[key].second]);
                 return recent[pos[key]].second;
             }
     
             return -1;
         }
     
         int Put(int key, int val){
             if(pos.find(key) != pos.end()){
                 recent.erase(pos[key]);
             }else if (pos.size() >= capacity){
                 pos.erase(recent.back().first);
                 recent.pop_back();
             }
     
             recent.push_front({key, val});
             pos[key] = recent.begin();
         }
     
     private:
         int capacity;
         list<pair<int, int>> recent;
         unordered_map<int, list< pair<int, int> >::iterator> pos;
     };
     ```

3. å¹¶æŸ¥é›†ç”Ÿæˆæ‰¾åˆ°æœ€å°ç”Ÿæˆæ ‘

   - æ ‡ç­¾ï¼š**å¹¶æŸ¥é›†**

   - è§£ç­”ï¼šæœ€å°ç”Ÿæˆæ ‘ï¼Œæ˜¯å°†ä¸€ä¸ªå›¾å½¢æˆä¸€ä¸ªè¿æ¥åˆ†é‡ï¼Œè€Œè¿™ä¸ªè¿æ¥åˆ†é‡çš„è¾¹çš„æƒå€¼ä¹‹å’Œæœ€å°ã€‚é‡‡ç”¨è´ªå¿ƒæ³•ï¼Œé¦–å…ˆå°†è¾¹æŒ‰æƒå€¼å¤§å°è¿›è¡Œæ’åºã€‚è¾¹æŒ‰å¤§å°é¡ºåºè¿›è¡Œè¿é€šï¼Œè¿é€šå‰æ£€æŸ¥è¯¥è¿é€šçš„å¤´æ˜¯å¦ç›¸åŒï¼Œå³æ˜¯å¦å½¢æˆç¯ï¼Œè‹¥å½¢æˆç¯åˆ™å–æ¶ˆè¯¥è¾¹çš„åŠ å…¥ï¼Œè‹¥ä¸å½¢æˆç¯åˆ™å°†è¯¥è¾¹åŠ å…¥åˆ°è¿é€šåˆ†é‡ï¼Œå½“è¿é€šäº†æ‰€æœ‰çš„ç‚¹ä¹‹åï¼Œåˆ™å½¢æˆäº†å·¦å³çš„æœ€å°çš„ç”Ÿæˆæ ‘

   - ä»£ç ï¼š

     ```c++
     #include <iostream>
     #include <vector>
     
     using namespace std;
     //ç¬¬ä¸€éƒ¨åˆ†å®Œæˆå¹¶æŸ¥é›†ç±»çš„è®¾è®¡
     
     class UnionFindSet {
         public:
         UnionFindSet(int s){
             size = s;
             parents = vector<int>(-1, s);
         }
         
         int Find(int x){
             if(parents[x] < 0) return x;
             return parents[x] = Find(parents[x]);
         }
         
         void Union(int root1, int root2){
             if(root1 == root2) return;
             if(parents[root1] < parents[root2]){
                 parents[root2] = root1;
                 parents[root1] += 1;
             }else {
                 parents[root1] = root2;
                 parents[root2] += 1;
             }
             return;    
         }    
         private:
         vector<int> parents;
         int size;    
     }
     
     
     struct Edge {
         int begin;
         int end;
         int val;
     }
     
     
     vector<Edge> krus(vector<Edge> edges, int n){
         vector<Edge> res;
     
         auto cmp = [](Edge left, Edge right){ return left.val > right.val};
         priority_queue<Edge, vector<Edge>, decltype(cmp)> q(cmp);
         
         UnionFindSet ufs = new UnionFindSet(n+1);
         for(auto edge : edges){
             q.push(edge);
         }
         int i= 0;
         while(i < n){
     		Edge temp = q.top();
             q.pop();
             
             if(ufs.Find(temp.begin) == ufs.Find(temp.end)){
                 continue;
             }else{
                	ufs.Union(ufs.Find(temp.begin), ufs.Find(temp.end));
                	res.push_back(temp);
                	i++;
             }
         }
         return res;
     }
     
     
     ```

4. æœ€çŸ­è·¯å¾„ç®—æ³•-dijskraç®—æ³•

   æ ‡ç­¾ï¼š**priority_queue**

   è§£ç­”ï¼šç®—æ³•æœ‰å‡ ä¸ªè¾…åŠ©çš„å­˜å‚¨ï¼Œ

   - disä¿å­˜æ¯ä¸ªç‚¹åˆ°èµ·ç‚¹çš„è·ç¦»çš„æ•°ç»„
   - visè®°å½•æ˜¯å¦æ‹œè®¿è¿‡
   - preè®°å½•é€šè¿‡è¯¥ç‚¹çš„ä¸Šä¸€ä¸ªæ‹œè®¿ç‚¹
   - priority_queueè®°å½•äº†å¯è®¿é—®ç‚¹çš„é›†åˆï¼Œä¿å­˜çš„æ˜¯pair<dis, node_id> è¯¥ç‚¹åˆ°èµ·ç‚¹çš„æœ€å°è·ç¦»ï¼Œé€šè¿‡ä¼˜å…ˆçº§å¯¹åˆ—æ¯æ¬¡éƒ½å°†æœ€å°è·ç¦»çš„ç‚¹å…ˆæ‹œè®¿ï¼Œè¿™æ ·å°±å½¢æˆäº†æœ€çŸ­è·¯å¾„ï¼Œåˆ°è¯¥ç‚¹çš„è·ç¦»æœ€çŸ­

   ä»£ç ï¼š

   ```c++
   int Dijkstra(int x){
       while(!q.empty()){
           pair<int, int> temp;
           temp = q.top();
           q.pop();
   
           if( vis[temp->second] != 0) continue;
           vis[temp->second]++;
   
           for(int i = 1; i <= M; i++){
               if(graph[temp->second][i] < INT_MAX && vis[i] != 0 && dis[i] > dis[temp->second] + graph[temp->second][i]){
                   dis[i] = dis[temp->second] + graph[temp->second][i];
                   pre[i] = temp->second;
                   q.push_back(make_pair(dis[i], i));
               }
           }
        }
   }
   ```


### é”™é¢˜é›†

| åºå· |         é¢˜ç›®         | ä»£ç  | è§£ç­” |
| :--: | :------------------: | :--: | :--: |
|  1   |     æ¸…é™¤æ³¨é‡Šä»£ç      |  ğŸ˜Š   |  ğŸ˜Š   |
|  2   |  ç©ºç¼ºçš„ç¬¬ä¸€ä¸ªæ­£æ•´æ•°  |  ğŸ˜¢   |  ğŸ˜¢   |
|  3   |  æ•°ç»„ç»„æˆæœ€å°çš„æ•´æ•°  |  ğŸ˜­   |  ğŸ˜­   |
|  4   | Knightèµ°æ£‹çš„æœ€å°æ­¥éª¤ |  ğŸ™‚   |  ğŸ™‚   |

1. remove comments from a given c/c++ program

   - **æ ‡ç­¾ï¼šc++, string**
   - è§£ç­”ï¼šæŒ‡å®šå•è¡Œæ³¨é‡Šæ ‡ç¤ºå’Œå¤šè¡Œæ³¨é‡Šæ ‡ç¤ºï¼Œå½“å¤„ç†æµç¨‹ä¸ºåˆ¤æ–­å½“å‰çš„æ˜¯å¦å¤„åœ¨æ³¨é‡ŠæœŸé—´ï¼Œå¤„ç†æµç¨‹ä¸ºï¼š
     - å¦‚æœåœ¨å•è¡Œæ³¨é‡ŠåŒºé—´ï¼Œæ˜¯å¦å½“äº†è¡Œå°¾
     - å¦‚æœåœ¨å¤šè¡Œæ³¨é‡ŠåŒºé—´ï¼Œæ˜¯å¦åœ¨å¤šè¡Œæ³¨é‡Šç»“å°¾
     - å¦‚æœåœ¨æ³¨é‡ŠåŒºé—´ï¼Œå½“å‰å­—ç¬¦ä¸¢å¼ƒ
     - å¦‚æœä¸åœ¨æ³¨é‡ŠåŒºé—´ï¼Œè€Œæ‰¾åˆ°äº†å•è¡Œæ³¨é‡Šçš„å¼€å¤´ï¼Œæ”¹å˜å•è¡Œæ³¨é‡Šçš„æ ‡ç¤º
     - ä¸åœ¨æ³¨é‡ŠåŒºé—´ï¼Œæ‰¾åˆ°äº†å¤šè¡Œæ³¨é‡Šçš„å¼€å¤´ï¼Œæ”¹å˜å¤šè¡Œæ³¨é‡Šçš„æ ‡ç¤º
     - å¦‚æœä¸åœ¨æ³¨é‡ŠåŒºé—´ï¼Œä¹Ÿæ²¡æ‰¾åˆ°æ ‡ç¤ºï¼Œåˆ™ç•™ä¸‹å½“å‰å­—ç¬¦

   ```c++
   #include <iostream>
   using namespace std;
   
   string removeComments(string prgm)
   {
       int n = prgm.length();
       string res;
   
       // Flags to indicate that single line and multpile line comments
       // have started or not.
       bool s_cmt = false;
       bool m_cmt = false;
   
       // Traverse the given program
       for (int i=0; i<n; i++)
       {
           // If single line comment flag is on, then check for end of it
           if (s_cmt == true && prgm[i] == '\n')
               s_cmt = false;
   
               // If multiple line comment is on, then check for end of it
           else if  (m_cmt == true && prgm[i] == '*' && prgm[i+1] == '/')
               m_cmt = false,  i++;
   
               // If this character is in a comment, ignore it
           else if (s_cmt || m_cmt)
               continue;
   
               // Check for beginning of comments and set the approproate flags
           else if (prgm[i] == '/' && prgm[i+1] == '/')
               s_cmt = true, i++;
           else if (prgm[i] == '/' && prgm[i+1] == '*')
               m_cmt = true,  i++;
   
               // If current character is a non-comment character, append it to res
           else  res += prgm[i];
       }
       return res;
   }
   
   // Driver program to test above functions 
   int main() 
   { 
       string prgm = "   /* Test program */ \n"
                     "   int main()  \n"
                     "   {           \n"
                     "      // variable declaration \n"
                     "      int a, b, c;    \n"
                     "      /* This is a test  \n"
                     "          multiline     \n"
                     "          comment for   \n"
                     "          testing */      \n"
                     "      a = b + c;       \n"
                     "   }           \n"; 
       cout << "Given Program \n"; 
       cout << prgm << endl; 
       cout << " Modified Program "; 
       cout << removeComments(prgm); 
       return 0; 
   }
   ```

2. ç©ºç¼ºçš„ç¬¬ä¸€ä¸ªæ­£æ•´æ•°

   - æ ‡ç­¾ï¼šarray

   - è§£ç­”ï¼š

     - ä½å›¾æ³•ï¼šå°†æ¯ä¸ªæ­£æ•´æ•°è¿›è¡ŒæŒ‰é¡ºåºè¿›è¡Œæ ‡è®°
     - è½¬æ¢ä½ç½®æ³•ï¼šå°†æ•°æ®æŒ‰å…¶å¤§å°æ”¾åˆ°è¯¥æ”¾çš„ä½ç½®ä¸Šï¼Œé€Ÿåº¦ä¸Šè¾ƒå¿«ï¼Œç¼ºç‚¹ï¼šå½“ä¸æ˜¯ä»0å¼€å§‹è®¡æ•°æ—¶ï¼Œåˆ™éœ€è¦å…ˆæ‰¾åˆ°æœ€å¤§çš„æ•°æ®
     - å»é‡åçš„æœ€å°å †ï¼šå°†æ•°æ®ä¸€ä¸ªä¸ªæ”¾å‡ºï¼Œæ˜¯å¦æ»¡è¶³è§„åˆ™ï¼Œä½†æ˜¯æ¯”è¾ƒæ…¢

   - ä»£ç ï¼š

     ```c++
     int firstMissingPositive(vector<int> &nums){
         int n = nums.size();
         for(int i = 0; i < n; i++){
             while(nums[i] != i + 1){
                 int v = nums[i];
                 // é’ˆå¯¹ä»0å¼€å§‹çš„ç¬¬ä¸€ä¸ªç¼ºå¤±çš„æ•°ï¼Œå¤§äº0çš„æ•°æ®å³å¯ä¸¢å¤±
                 if(v > n || v <= 0) break;
                 else{
                     if(nums[v-1] == v) break;
                     swap(nums[v - 1], nums[i]);
                 }
             }
         }
         
         for(int i=0; i < n; i++){
             if(nums[i] != i + 1) return i +1;
         }
        
         return n + 1;    
     }
     ```

3. æ•°ç»„ç»„æˆæœ€å°çš„æ•´æ•°

   æ ‡ç­¾: string

   è§£æ³•ï¼šç†è§£æ¯”è¾ƒç®—æ³•ï¼Œé€šè¿‡å­—ç¬¦ä¸²å¤§å°çš„æ¯”è¾ƒå¾—åˆ°å­—ç¬¦ä¸²ç›¸å¯¹çš„ä½ç½®ï¼Œæœ€åå°†å­—ç¬¦ä¸²çš„ä½ç½®ä¸²èµ·æ¥å°±å¯ä»¥å¾—åˆ°æœ€åç»„æˆçš„æœ€å°çš„å­—ç¬¦ä¸²ï¼Œç”±äºç®—æ³•é¢˜éœ€è¦è¯æ˜å­—ç¬¦ä¸²æ¯”è¾ƒçš„å„ç§å»¶å±•å’Œä¼ é€’æ€§ï¼Œè¿™é‡Œä¸å±•å¼€æ¯”è¾ƒã€‚

   ä»£ç ï¼š

   ```C++
   //
   // Created by zhanGGe on 2018/10/23.
   //
   
   #include <iostream>
   #include <string>
   #include <vector>
   
   using namespace std;
   
   
   int main(){
   
       int N;
       cin >> N;
       vector<string> data_s(N, "");
       for(int i = 0; i < N; i++){
           cin >> data_s[i];
       }
   
       for(int i = 0; i < N; i++){
           for(int j = 0; j < N - i - 1; j++){
               if(data_s[i] > data_s[i+1]){
                   string temp = data_s[i];
                   data_s[i] = data_s[i + 1];
                   data_s[i + 1] = temp;
               }
           }
       }
   
       string res = "";
   
       for(int i = 0 ; i < N; i++){
           res += data_s[i];
       }
   
       cout << res << endl;
   
   
       return 0;
   
   }
   ```

   åæ€ï¼šå¯¹stringè¿˜æ˜¯ä¸æ˜¯å¾ˆç†Ÿæ‚‰ï¼Œé»˜è®¤çš„åº“é‡Œå·²ç»å¯¹stringçš„å„ç§æ“ä½œç¬¦è¿›è¡Œäº†é‡è½½å®Œå…¨å¯ä»¥é‡æ–°ä½¿ç”¨åŒ…æ‹¬â€œ+â€ï¼Œ ">"ç­‰ç­‰ã€‚å¯¹äºå‰‘æŒ‡offerçš„é¢˜ç›®çš„ç†è§£å’Œç»ƒä¹ æ¼æ´å¤ªå¤šäº†ã€‚

4. knightçš„æœ€å°æ­¥æ•°

   å…³é”®è¯ï¼š bfs

   è§£æï¼šå½“å¤„ç†å›¾ä¸­æœ€å°æ­¥æ•°é—®é¢˜çš„æ—¶å€™ï¼Œç›´æ¥æƒ³åˆ°æœ€çŸ­è·¯åŠ²é—®é¢˜ï¼Œæœ€çŸ­è·¯å¾„çš„å®ç°å®é™…ä¸Šå°±æ˜¯åˆ©ç”¨çš„bfsï¼Œåˆ†å±‚å»æ¢ç´¢ä¸åŒçš„è·¯ï¼Œå½“æ‰¾åˆ°é‡ç‚¹æ—¶åé¦ˆè¡Œèµ°çš„æ­¥æ•°ï¼Œè‹¥é˜Ÿåˆ—éƒ½popå®Œäº†è¿˜æ˜¯æ²¡æ‰¾åˆ°ï¼Œåˆ™ä¸å¯èƒ½åˆ°è¾¾æ”¹ç‚¹è¿”å›-1.

   ä»£ç ï¼š

   ```c++
   //
   // Created by zhanGGe on 2018/10/23.
   //
   
   #include <iostream>
   #include <vector>
   #include <queue>
   
   using namespace std;
   
   int moves[][2] = {{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};
   
   struct pos{
       int x;
       int y;
       pos(int m, int n){
           x = m;
           y = n;
       }
   };
   
   int main(){
       queue<pos> q;
       pos start(2, 2);
       q.push(start);
       int D_x = 0;
       int D_y = 1;
       int M = 5;
       int N = 5;
       int count = 0;
   
       if(start.x == D_x && start.y == D_y) {
           cout << 0;
           return 0;
       }
   
       while(!q.empty()){
           count++;
           pos temp = q.front();
           q.pop();
           for(auto move : moves){
               int x = temp.x + move[0];
               int y = temp.y + move[1];
   
               if(x== D_x && y == D_y){
                   cout << count << endl;
                   return 0;
               }
   
               if(x >=0 && x < M && y >= 0 && y < M){
                   q.push(pos(x, y));
               }
           }
       }
       cout << -1 << endl;
       return 0;
   }
   ```

   åæ€ï¼š

   - å¯¹queueçš„å‡ ä¸ªæ“ä½œè¿˜ä¸ç†Ÿæ‚‰
     - front() è¿”å› é˜Ÿåˆ—çš„å¤´
     - back() è¿”å›é˜Ÿåˆ—çš„å°¾
     - push() æ’å…¥å…ƒç´ åœ¨å°¾éƒ¨
     - pop() åœ¨å¤´éƒ¨åˆ é™¤å…ƒç´   
   - å¯¹äºå›¾æˆ–è€…æ ‘çš„BFSçš„ç†è§£ä¸å¤Ÿ
     - BFSè‚¯å®šç±»ä¼¼äºå±‚æ¬¡éå†ï¼Œè‚¯å®šä¸èƒ½é‡‡ç”¨é€’å½’çš„æ–¹æ³•ï¼Œéœ€è¦ä½¿ç”¨éé€’å½’åŠ queueçš„æ–¹æ³•å»ä½¿ç”¨

#### åŠ¨æ€è§„åˆ’ä¸“é¢˜

1. æœ€é•¿æœ‰æ•ˆæ‹¬å·å¯¹

2. Unique Path II æœ‰éšœç¢ç‰©æƒ…å†µä¸‹ï¼Œä¸€ç‚¹åˆ°å¦å¤–ä¸€ç‚¹çš„èµ°æ³•

| åºå· |             é¢˜ç›®             | è§£ç­” | ä»£ç  |
| :--: | :--------------------------: | :--: | :--: |
|  1   | å°†æ•°æ®å°½é‡å¹³å‡çš„åˆ†åˆ°ä¸¤ä¸ªæ•°ç»„ |  [ğŸ¤£](#jump)   |  ğŸ¤£   |
|      |                              |      |      |
|      |                              |      |      |

3. å°†æ•°æ®å°½é‡å¹³å‡çš„åˆ†åˆ°ä¸¤ä¸ªæ•°ç»„

   å…³é”®è¯ï¼š åŠ¨æ€è§„åˆ’

   è§£ç­”ï¼š å°†æ•°ç»„å°½é‡å¹³å‡çš„åˆ†é…åˆ°ä¸¤ä¸ªæ•°ç»„ï¼Œå¯ä»¥è½¬åŒ–ä¸ºå°†æ•°æ®æ”¾åˆ°zongzhizongzhi



#### æµ·é‡æ•°æ®å¤„ç†

##### TopNçš„é—®é¢˜

1. æµ·é‡æ•°æ®ä¸­æ‰¾åˆ°é‡å¤æ¬¡æ•°æœ€å¤šçš„ä¸€ä¸ª

##### å†…å­˜å¯ä»¥æ”¾ä¸‹çš„TopNé—®é¢˜

1. å¿«æ’é™ä½æ’åºæ•°é‡
2. å †æ’åºï¼Œä¿ç•™topN

#### ä½å›¾æ³•

1. åœ¨2.5äº¿æ•°å­—ä¸­æ‰¾å‡ºä¸é‡å¤çš„æ•°å­—
   - ä½¿ç”¨2-bitä½å›¾æ³•ï¼Œ00è¡¨ç¤ºä¸å­˜åœ¨ï¼Œ01è¡¨ç¤ºå‡ºç°ä¸€æ¬¡ï¼Œ 10è¡¨ç¤ºå‡ºç°å¤šæ¬¡ï¼Œ11è¡¨ç¤ºæ— æ„ä¹‰ã€‚è¿™æ ·éœ€è¦1Gå†…å­˜
   - æˆ–è€…hashåˆ’åˆ†å°æ–‡ä»¶ï¼Œå°æ–‡ä»¶ä½¿ç”¨hash_setæ£€æŸ¥å„ä¸ªå…ƒç´ ï¼Œå¾—åˆ°ä¸é‡å¤çš„æ•´æ•°
2. å¦‚ä½•åœ¨40äº¿æ•°å­—ä¸­åˆ¤æ–­æ˜¯å¦æœ‰æŸä¸ªæ•°
   - ä½å›¾æ³•æ ‡è®°æŸä¸ªæ•°æ˜¯å¦å­˜åœ¨ï¼Œcheckæ ‡è®°æ•°ç»„






<span id="jump">Hello World</span>
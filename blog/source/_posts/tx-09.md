---
title: 数据机构与算法
date: 2018-10-04 19:08:13
tags: 数据结构
---

### leetcode列表

| 序号 |         题目          | 代码 | 解答 |
| :--: | :-------------------: | :--: | :--: |
|  1   | 二叉搜索树的第k大节点 |  😊   |  😊   |
|      |                       |      |      |
|      |                       |      |      |

解答：

1. 二叉搜索树的第K大节点

   - 解答：二叉搜索树的中序遍历有序的特点

   - 代码

     ```c++
     #include <iostream>
     #include <stack>
     
     using namespace std;
     
     int midTravelKthest(TreeNode* root, int k){
         TreeNode* p = root;
         stack<TreeNode*> s;
     	int count = 0;   
         while(p || !s.empty()){
             if(p){
               s.push(p);
               p = p->left;  
             }else{
                 p = s.top();
                 s.pop();
                 count++;
                 if (count == k) {
                     cout << p->val << endl;
                     return;
                 }
                 p = p->right;
             }    
         }
     }
     ```

### 错题集

| 序号 |        题目        | 代码 | 解答 |
| :--: | :----------------: | :--: | :--: |
|  1   |    清除注释代码    |  😊   |  😊   |
|  2   | 空缺的第一个正整数 |  😢   |  😢   |

1. remove comments from a given c/c++ program

   - **标签：c++, string**
   - 解答：指定单行注释标示和多行注释标示，当处理流程为判断当前的是否处在注释期间，处理流程为：
     - 如果在单行注释区间，是否当了行尾
     - 如果在多行注释区间，是否在多行注释结尾
     - 如果在注释区间，当前字符丢弃
     - 如果不在注释区间，而找到了单行注释的开头，改变单行注释的标示
     - 不在注释区间，找到了多行注释的开头，改变多行注释的标示
     - 如果不在注释区间，也没找到标示，则留下当前字符

   ```c++
   #include <iostream>
   using namespace std;
   
   string removeComments(string prgm)
   {
       int n = prgm.length();
       string res;
   
       // Flags to indicate that single line and multpile line comments
       // have started or not.
       bool s_cmt = false;
       bool m_cmt = false;
   
       // Traverse the given program
       for (int i=0; i<n; i++)
       {
           // If single line comment flag is on, then check for end of it
           if (s_cmt == true && prgm[i] == '\n')
               s_cmt = false;
   
               // If multiple line comment is on, then check for end of it
           else if  (m_cmt == true && prgm[i] == '*' && prgm[i+1] == '/')
               m_cmt = false,  i++;
   
               // If this character is in a comment, ignore it
           else if (s_cmt || m_cmt)
               continue;
   
               // Check for beginning of comments and set the approproate flags
           else if (prgm[i] == '/' && prgm[i+1] == '/')
               s_cmt = true, i++;
           else if (prgm[i] == '/' && prgm[i+1] == '*')
               m_cmt = true,  i++;
   
               // If current character is a non-comment character, append it to res
           else  res += prgm[i];
       }
       return res;
   }
   
   // Driver program to test above functions 
   int main() 
   { 
       string prgm = "   /* Test program */ \n"
                     "   int main()  \n"
                     "   {           \n"
                     "      // variable declaration \n"
                     "      int a, b, c;    \n"
                     "      /* This is a test  \n"
                     "          multiline     \n"
                     "          comment for   \n"
                     "          testing */      \n"
                     "      a = b + c;       \n"
                     "   }           \n"; 
       cout << "Given Program \n"; 
       cout << prgm << endl; 
       cout << " Modified Program "; 
       cout << removeComments(prgm); 
       return 0; 
   }
   ```

2. 空缺的第一个正整数

   - 标签：array

   - 解答：

     - 位图法：将每个正整数进行按顺序进行标记
     - 转换位置法：将数据按其大小放到该放的位置上，速度上较快，缺点：当不是从0开始计数时，则需要先找到最大的数据
     - 去重后的最小堆：将数据一个个放出，是否满足规则，但是比较慢

   - 代码：

     ```c++
     int firstMissingPositive(vector<int> &nums){
         int n = nums.size();
         for(int i = 0; i < n; i++){
             while(nums[i] != i + 1){
                 int v = nums[i];
                 // 针对从0开始的第一个缺失的数，大于0的数据即可丢失
                 if(v > n || v <= 0) break;
                 else{
                     if(nums[v-1] == v) break;
                     swap(nums[v - 1], nums[i]);
                 }
             }
         }
         
         for(int i=0; i < n; i++){
             if(nums[i] != i + 1) return i +1;
         }
        
         return n + 1;    
     }
     ```


#### 海量数据处理

##### TopN的问题

1. 海量数据中找到重复次数最多的一个

##### 内存可以放下的TopN问题

1. 快排降低排序数量
2. 堆排序，保留topN

#### 位图法

1. 在2.5亿数字中找出不重复的数字
   - 使用2-bit位图法，00表示不存在，01表示出现一次， 10表示出现多次，11表示无意义。这样需要1G内存
   - 或者hash划分小文件，小文件使用hash_set检查各个元素，得到不重复的整数
2. 如何在40亿数字中判断是否有某个数
   - 位图法标记某个数是否存在，check标记数组
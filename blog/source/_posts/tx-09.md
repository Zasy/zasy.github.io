---
title: 数据机构与算法
date: 2018-10-04 19:08:13
tags: 
- 数据结构
- 算法
- leetcode
---

### leetcode列表

| 序号 |         题目          | 代码 | 解答 |
| :--: | :-------------------: | :--: | :--: |
|  1   | 二叉搜索树的第k大节点 |  😊   |  😊   |
|  2   |    实现LRU内存模型    |  😊   |  😊   |
|  3   | 并查集实现最小生成树  |  😊   |  😊   |
|  4   |     最短路径算法      |  🙂   |  🙂   |

解答：

1. 二叉搜索树的第K大节点

   - 解答：二叉搜索树的中序遍历有序的特点

   - 代码

     ```c++
     #include <iostream>
     #include <stack>
     
     using namespace std;
     
     int midTravelKthest(TreeNode* root, int k){
         TreeNode* p = root;
         stack<TreeNode*> s;
     	int count = 0;   
         while(p || !s.empty()){
             if(p){
               s.push(p);
               p = p->left;  
             }else{
                 p = s.top();
                 s.pop();
                 count++;
                 if (count == k) {
                     cout << p->val << endl;
                     return;
                 }
                 p = p->right;
             }    
         }
     }
     ```

2. 实现LRU内存模型

   - 解答：

     - get操作，先检查pos 优先级set里面是否有该元素，如果有则重新put该k-value。
     - put操作，先检查其中pos是否有该key，如果有，则erase该元素 通过iterator，如果没有，则检查元素的个数是否达到了capacity，如果到了就要将list队尾元素erase掉；最后统一的在队列最前面插入元素，并在pos中记录其位置

   - 代码：

     ```c++
     class LRU {
     public:
         LRU : capacity(int ca){}
     
         int Get(int key){
             if(pos.find(key) != pos.end()){
                 Put(key, recent[pos[key].second]);
                 return recent[pos[key]].second;
             }
     
             return -1;
         }
     
         int Put(int key, int val){
             if(pos.find(key) != pos.end()){
                 recent.erase(pos[key]);
             }else if (pos.size() >= capacity){
                 pos.erase(recent.back().first);
                 recent.pop_back();
             }
     
             recent.push_front({key, val});
             pos[key] = recent.begin();
         }
     
     private:
         int capacity;
         list<pair<int, int>> recent;
         unordered_map<int, list< pair<int, int> >::iterator> pos;
     };
     ```

3. 并查集生成找到最小生成树

   - 标签：**并查集**

   - 解答：最小生成树，是将一个图形成一个连接分量，而这个连接分量的边的权值之和最小。采用贪心法，首先将边按权值大小进行排序。边按大小顺序进行连通，连通前检查该连通的头是否相同，即是否形成环，若形成环则取消该边的加入，若不形成环则将该边加入到连通分量，当连通了所有的点之后，则形成了左右的最小的生成树

   - 代码：

     ```c++
     #include <iostream>
     #include <vector>
     
     using namespace std;
     //第一部分完成并查集类的设计
     
     class UnionFindSet {
         public:
         UnionFindSet(int s){
             size = s;
             parents = vector<int>(-1, s);
         }
         
         int Find(int x){
             if(parents[x] < 0) return x;
             return parents[x] = Find(parents[x]);
         }
         
         void Union(int root1, int root2){
             if(root1 == root2) return;
             if(parents[root1] < parents[root2]){
                 parents[root2] = root1;
                 parents[root1] += 1;
             }else {
                 parents[root1] = root2;
                 parents[root2] += 1;
             }
             return;    
         }    
         private:
         vector<int> parents;
         int size;    
     }
     
     
     struct Edge {
         int begin;
         int end;
         int val;
     }
     
     
     vector<Edge> krus(vector<Edge> edges, int n){
         vector<Edge> res;
     
         auto cmp = [](Edge left, Edge right){ return left.val > right.val};
         priority_queue<Edge, vector<Edge>, decltype(cmp)> q(cmp);
         
         UnionFindSet ufs = new UnionFindSet(n+1);
         for(auto edge : edges){
             q.push(edge);
         }
         int i= 0;
         while(i < n){
     		Edge temp = q.top();
             q.pop();
             
             if(ufs.Find(temp.begin) == ufs.Find(temp.end)){
                 continue;
             }else{
                	ufs.Union(ufs.Find(temp.begin), ufs.Find(temp.end));
                	res.push_back(temp);
                	i++;
             }
         }
         return res;
     }
     
     
     ```

4. 最短路径算法-dijskra算法

   标签：**priority_queue**

   解答：算法有几个辅助的存储，

   - dis保存每个点到起点的距离的数组
   - vis记录是否拜访过
   - pre记录通过该点的上一个拜访点
   - priority_queue记录了可访问点的集合，保存的是pair<dis, node_id> 该点到起点的最小距离，通过优先级对列每次都将最小距离的点先拜访，这样就形成了最短路径，到该点的距离最短

   代码：

   ```c++
   int Dijkstra(int x){
       while(!q.empty()){
           pair<int, int> temp;
           temp = q.top();
           q.pop();
   
           if( vis[temp->second] != 0) continue;
           vis[temp->second]++;
   
           for(int i = 1; i <= M; i++){
               if(graph[temp->second][i] < INT_MAX && vis[i] != 0 && dis[i] > dis[temp->second] + graph[temp->second][i]){
                   dis[i] = dis[temp->second] + graph[temp->second][i];
                   pre[i] = temp->second;
                   q.push_back(make_pair(dis[i], i));
               }
           }
        }
   }
   ```


### 错题集

| 序号 |         题目         | 代码 | 解答 |
| :--: | :------------------: | :--: | :--: |
|  1   |     清除注释代码     |  😊   |  😊   |
|  2   |  空缺的第一个正整数  |  😢   |  😢   |
|  3   |  数组组成最小的整数  |  😭   |  😭   |
|  4   | Knight走棋的最小步骤 |  🙂   |  🙂   |

1. remove comments from a given c/c++ program

   - **标签：c++, string**
   - 解答：指定单行注释标示和多行注释标示，当处理流程为判断当前的是否处在注释期间，处理流程为：
     - 如果在单行注释区间，是否当了行尾
     - 如果在多行注释区间，是否在多行注释结尾
     - 如果在注释区间，当前字符丢弃
     - 如果不在注释区间，而找到了单行注释的开头，改变单行注释的标示
     - 不在注释区间，找到了多行注释的开头，改变多行注释的标示
     - 如果不在注释区间，也没找到标示，则留下当前字符

   ```c++
   #include <iostream>
   using namespace std;
   
   string removeComments(string prgm)
   {
       int n = prgm.length();
       string res;
   
       // Flags to indicate that single line and multpile line comments
       // have started or not.
       bool s_cmt = false;
       bool m_cmt = false;
   
       // Traverse the given program
       for (int i=0; i<n; i++)
       {
           // If single line comment flag is on, then check for end of it
           if (s_cmt == true && prgm[i] == '\n')
               s_cmt = false;
   
               // If multiple line comment is on, then check for end of it
           else if  (m_cmt == true && prgm[i] == '*' && prgm[i+1] == '/')
               m_cmt = false,  i++;
   
               // If this character is in a comment, ignore it
           else if (s_cmt || m_cmt)
               continue;
   
               // Check for beginning of comments and set the approproate flags
           else if (prgm[i] == '/' && prgm[i+1] == '/')
               s_cmt = true, i++;
           else if (prgm[i] == '/' && prgm[i+1] == '*')
               m_cmt = true,  i++;
   
               // If current character is a non-comment character, append it to res
           else  res += prgm[i];
       }
       return res;
   }
   
   // Driver program to test above functions 
   int main() 
   { 
       string prgm = "   /* Test program */ \n"
                     "   int main()  \n"
                     "   {           \n"
                     "      // variable declaration \n"
                     "      int a, b, c;    \n"
                     "      /* This is a test  \n"
                     "          multiline     \n"
                     "          comment for   \n"
                     "          testing */      \n"
                     "      a = b + c;       \n"
                     "   }           \n"; 
       cout << "Given Program \n"; 
       cout << prgm << endl; 
       cout << " Modified Program "; 
       cout << removeComments(prgm); 
       return 0; 
   }
   ```

2. 空缺的第一个正整数

   - 标签：array

   - 解答：

     - 位图法：将每个正整数进行按顺序进行标记
     - 转换位置法：将数据按其大小放到该放的位置上，速度上较快，缺点：当不是从0开始计数时，则需要先找到最大的数据
     - 去重后的最小堆：将数据一个个放出，是否满足规则，但是比较慢

   - 代码：

     ```c++
     int firstMissingPositive(vector<int> &nums){
         int n = nums.size();
         for(int i = 0; i < n; i++){
             while(nums[i] != i + 1){
                 int v = nums[i];
                 // 针对从0开始的第一个缺失的数，大于0的数据即可丢失
                 if(v > n || v <= 0) break;
                 else{
                     if(nums[v-1] == v) break;
                     swap(nums[v - 1], nums[i]);
                 }
             }
         }
         
         for(int i=0; i < n; i++){
             if(nums[i] != i + 1) return i +1;
         }
        
         return n + 1;    
     }
     ```

3. 数组组成最小的整数

   标签: string

   解法：理解比较算法，通过字符串大小的比较得到字符串相对的位置，最后将字符串的位置串起来就可以得到最后组成的最小的字符串，由于算法题需要证明字符串比较的各种延展和传递性，这里不展开比较。

   代码：

   ```C++
   //
   // Created by zhanGGe on 2018/10/23.
   //
   
   #include <iostream>
   #include <string>
   #include <vector>
   
   using namespace std;
   
   
   int main(){
   
       int N;
       cin >> N;
       vector<string> data_s(N, "");
       for(int i = 0; i < N; i++){
           cin >> data_s[i];
       }
   
       for(int i = 0; i < N; i++){
           for(int j = 0; j < N - i - 1; j++){
               if(data_s[i] > data_s[i+1]){
                   string temp = data_s[i];
                   data_s[i] = data_s[i + 1];
                   data_s[i + 1] = temp;
               }
           }
       }
   
       string res = "";
   
       for(int i = 0 ; i < N; i++){
           res += data_s[i];
       }
   
       cout << res << endl;
   
   
       return 0;
   
   }
   ```

   反思：对string还是不是很熟悉，默认的库里已经对string的各种操作符进行了重载完全可以重新使用包括“+”， ">"等等。对于剑指offer的题目的理解和练习漏洞太多了。

4. knight的最小步数

   关键词： bfs

   解析：当处理图中最小步数问题的时候，直接想到最短路劲问题，最短路径的实现实际上就是利用的bfs，分层去探索不同的路，当找到重点时反馈行走的步数，若队列都pop完了还是没找到，则不可能到达改点返回-1.

   代码：

   ```c++
   //
   // Created by zhanGGe on 2018/10/23.
   //
   
   #include <iostream>
   #include <vector>
   #include <queue>
   
   using namespace std;
   
   int moves[][2] = {{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};
   
   struct pos{
       int x;
       int y;
       pos(int m, int n){
           x = m;
           y = n;
       }
   };
   
   int main(){
       queue<pos> q;
       pos start(2, 2);
       q.push(start);
       int D_x = 0;
       int D_y = 1;
       int M = 5;
       int N = 5;
       int count = 0;
   
       if(start.x == D_x && start.y == D_y) {
           cout << 0;
           return 0;
       }
   
       while(!q.empty()){
           count++;
           pos temp = q.front();
           q.pop();
           for(auto move : moves){
               int x = temp.x + move[0];
               int y = temp.y + move[1];
   
               if(x== D_x && y == D_y){
                   cout << count << endl;
                   return 0;
               }
   
               if(x >=0 && x < M && y >= 0 && y < M){
                   q.push(pos(x, y));
               }
           }
       }
       cout << -1 << endl;
       return 0;
   }
   ```

   反思：

   - 对queue的几个操作还不熟悉
     - front() 返回 队列的头
     - back() 返回队列的尾
     - push() 插入元素在尾部
     - pop() 在头部删除元素  
   - 对于图或者树的BFS的理解不够
     - BFS肯定类似于层次遍历，肯定不能采用递归的方法，需要使用非递归加queue的方法去使用

#### 动态规划专题

1. 最长有效括号对

2. Unique Path II 有障碍物情况下，一点到另外一点的走法

| 序号 |             题目             | 解答 | 代码 |
| :--: | :--------------------------: | :--: | :--: |
|  1   | 将数据尽量平均的分到两个数组 |  [🤣](#jump)   |  🤣   |
|      |                              |      |      |
|      |                              |      |      |

3. 将数据尽量平均的分到两个数组

   关键词： 动态规划

   解答： 将数组尽量平均的分配到两个数组，可以转化为将数据放到zongzhizongzhi



#### 海量数据处理

##### TopN的问题

1. 海量数据中找到重复次数最多的一个

##### 内存可以放下的TopN问题

1. 快排降低排序数量
2. 堆排序，保留topN

#### 位图法

1. 在2.5亿数字中找出不重复的数字
   - 使用2-bit位图法，00表示不存在，01表示出现一次， 10表示出现多次，11表示无意义。这样需要1G内存
   - 或者hash划分小文件，小文件使用hash_set检查各个元素，得到不重复的整数
2. 如何在40亿数字中判断是否有某个数
   - 位图法标记某个数是否存在，check标记数组






<span id="jump">Hello World</span>
---
title: 网络通信基础
date: 2018-10-04 19:08:13
tags: http tcp udp
---

### 网络通信

OSI七层通信协议模型

- 物理层 电线、光纤
- 数据链路层 网关、ARP、Mac地址 帧
- 网络层 IP传输 数据包
- 传输层 TCP UDP
- 会话层 
- 表示层
- 应用层

#### 传输层

1. 表示层和会话层的功能是什么

   1. 表示层，对数据的表示，编解码 (图像，视频，数据编解码)
   2. 会话层： 建立会话， 如session认证，断点续传

2. 描述TCP的头部

   - 源端口号(16bit) 和 目的端口号(16bit)

   - 序号（32bit）： 字节流的字节编号，用于解决网络传输的乱序的问题；
   - 确认号 (32bit) :  接收方给发送方确认报文的编号，其值是收到的序号+1；
   - 首部长(4bit): 标识首部的长度为多少个4字节
   - 标志位(6bit)：
     - URG：是否紧急
     - ACK：确认报文段
     - PSH： 提示接收方理解从缓存中读取数据
     - RST: 复位报文段
     - SYN：表示请求建立一个连接
     - FIN：表示请求中断连接
   - 窗口(16bit)：接受窗口，告知对方（发送方）本方还有多少空间可以接受数据。用于流量控制
   - 校验和(16bit): 检查报文段是否有损坏

3. TCP socket交互流程

   - 服务器：

     - 创建socket, int socket(int domain, int type,int protool)

     - 绑定socket和端口号, int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)

     - ```
           // IPv4的sockaddr地址结构
           struct sockaddr_in {
               sa_family_t sin_family;    // 协议类型，AF_INET
               in_port_t sin_port;    // 端口号
               struct in_addr sin_addr;    // IP地址
           };
           struct in_addr {
               uint32_t s_addr;
           }
       ```

       addrlen：地址长度。

     - 监听端口号 -> int listen(int sockfd, int backlog);

       - 要监听的sock描述字
       - 可以排队的最大连接数

     - 接收用户请求 -> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

       - 

4. IO的分类和实现方式

   1. 同步、异步、轮询和回调的不同之处

      本质：进程间的通信的方式

       1. 信号量

          不同的信号在通信的时候，需要指定信号的通信方式，需要是同步还是一部的—**linux的通信方式的复习**

      - 同步：同步及单次的写入不完成就不返回，进程阻塞在单次的请求中，不去做其他的事情
      - 异步：异步，当前进程被阻塞时，先返回，请求的结构暂时不返回。
      - 轮询：异步请求返回的结果通知有很多的方式，一种是通知的方式，这样当前需要不算的轮询返回的结果，这样相当于需要不断的轮询是否有通知到达
      - 回调：异步返回的结果，通过直接告知的方式，底层可以通过信号量的方式进行实现，这样当前进程不需要不断轮询单次请求是否有结果返回。效率更高。

   2. 

5. TCP通信在底层发生了什么？

   - 建立连接后内核发生了什么？

     当建立socket连接的时候，内核省成本了两条队列：一条用了装正在请求的客户端请求；一条用来装已经建立了连接的请求

   - 系统文件中哪里有sockets相关的信息

     1. `/proc/<pid>/net/tcp` 目前已经激活的饿TCP连接
     2. `/proc/<pid>/fd` 被程序打开的文件描述符列表
     3. `/proc/<pid>/net/sockstat 当前TCP连接的概述信息`

   - 当socket连接被请求时，会发生什么？
     1. socket struct 的结构以及它对于套接字的意义
     2. 内核是怎么和IO的端口文件结合起来的，
     3. 在做IO的TCP的协议的具体过程是哪些方法在哪里实现的 (内核的实现)

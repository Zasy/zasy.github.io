---
title: 操作系统基础
date: 2018-10-04 19:08:13
tags: 操作系统
---

### 操作系统

[TOC]



#### 进程线程模型

对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。**==其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。==**

##### 多线程

特征：

1. 一个进程下有多个线程
2. 所有线程共享同一个进程的内存空间
3. 由于线程的访问顺序不同，需要注意对临界变量的访问---> 产生冒险 相同的代码由于调度的顺序不同导致不同的结果

好处：

1. 不同的线程可以独立的完成工作
2. 线程的切换的效率要高很多

关键点：

1. 线程之间有无先后访问的顺序 （线程的依赖关系）
2. 线程共享访问同一变量（同步互斥问题）

##### 进程

一个可执行文件**(程序**)的内容：

- 二进制格式标识
- 机器语言指令
- 程序的入口地址
- 数据
- 符号表及重定位表
- 共享库和动态链接信息
- 其他信息：程序文件包含很多其他信息

**进程内存布局**

- 进程的内存分配 P96

  1. 文本段
  2. 初始化数据段
  3. 未初始化数据段
  4. 堆
  5. 栈-（为每个函数设置栈帧，包括函数的地址，变量）
  6. argv 和 environ
  7. 映射到内核的数据结构

- 虚拟内存管理 P98

  1. 为什么可以用虚拟内存进行管理，局部性原理
     1. 时间局部性
     2. 空间局部性
  2. 内核为每一个进程维护一个页表

- 栈和栈帧

  栈 为 每个调用的函数分配一个栈帧，其中包括

  - 函数实参和局部变量
  - 调用的链接信息 （CPU寄存器，程序计数器，下一条机器指令的地址）。当调用另一函数时，会在被调用的栈帧中保存这个寄存器的副本，以便函数返回时能为函数调用者将寄存器恢复。

- 跳转和优化编译器的问题

  - 优化编译器会导致部分变量存储在CPU寄存器中，在执行跳转命令时，类似于(goto)会发生错误，volatile会避免这种优化

##### 系统限制和选项

##### 系统和进程信息

- 进程信息：/proc/PID/
  - /proc/PID/fd 打开的文件描述符
  - /proc/PID/task 目录
    - /proc/PID/task/TID  为进程下的每个线程建立的一个目录
- 系统信息：

##### 文件I/O缓冲

1. 为什么要有对文件I/O进行缓存？

   采用这样的操作主要是因为磁盘操作的速度太慢，这样不需要等待磁盘的操作。

2. 控制文件I/O的内核缓存
   1. 设置为完整的同步IO -- 直接同步到磁盘
   2. 绕过内核的高速缓存：直接I/O

##### 文件系统

##### 目录与链接

1. 目录
   - i-node表中，会将目录记录为一种文件类型
   - 作为文件的目录，本质上是一个表格，包含文件名和i-node编号

2. 硬链接

   定义： 在相同或者不同目录的文件，指向同一个i-node编号，这样就可以实现硬链接

   方法： `ln abc xyz` 

   实质：在对应的目录文件中，多记录一个文件，指向同一个i-node ，i-node有一个字段记录了当前链接的目录的个数，只有当删除所有链接时，该文件的数据块才被删除

3. 符号链接

   定义：一种特殊的文件类型，数据是另外一个文件的文件名

   方法： `ln -s test.txt newtest.txt`

   实质：在目录下新建了一个文件，数据为该文件的全路径文件名

4. 硬链接和软链接的差别
   1. 硬链接由于必须指向同一个文件系统内的i-node，所以只能在同一文件系统中建立硬链接
   2. 不能为目录创建硬链接，容易形成环



#### 信号

1. 概念和概述

   - 信号是事件发生时对进程的通知机制，也叫软件中断。
   - 通常是，内核为进程产生信号：
     1. 硬件异常
     2. 特殊终端字符 (Ctrl-Z or Ctrl-C)
     3. 发生软件事件
   - 信号的分类：
     1. 标准信号：内核向进程通知事件，编号范围1-31
     2. 实时信号：

   // TO-DO

   // 待完善 执行

2. 进程的创建

   1. pid_t fork()
      - 对父进程内存相应部分的完全复制
      - 父子进程的文件共享，得益于文件描述符记录表和系统级的打开文件表
      - 写时复制的内存语义，刚fork()的时候，内存都是只读状态，这样共享同样的物理内存页，当需要加载新的程序，或者修改对应的内存块时，会新建新的物理内存块，修改对应的虚拟地址对应的页。
      - vfork() 
        - 无需为子进程虚拟内页或页表，和父进程共享内存，知道成功的执行exec()或调用了_exit()退出。
        - 在子进程调用exec()或是调用_exit()之前暂停执行父进程
        - 系统保障子进程先收到CPU的调度
      - fork() 后存在竞争状态，如果有同步的需要，可以用信号，或者进程间通信的方式，进行同步
   2. 进程终止exit()
      - _exit()
      - 分为正常关闭和异常关闭
      - 都会执行多个清理的步骤，包括文件相关，进程间通信相关、内存释放相关和Stdio缓存的刷新

   3. pid_t wait(&status)

      - 当存在未被等待返回的子进程时，会一直阻塞。

      - 当所有的子进程都已被等待返回，则会产生错误 等于 -1， 并且使 errno 为 ECHILD，可以用来等待所有子进程释放

      - 正常返回子进程的pid

      - waitpid() 指定对应的pid，进行等待，补充上述的系统调用的不足之处

      - **孤儿进程和僵尸进程**

        - 由于父子进程的时间长度不同，必然会导致一些父进程会先于子进程退出，这样就会由众进程之祖(init)接管。

          这样的进程就是孤儿进程

        - 在父进程执行wait()之前，子进程就已经终止，系统任然允许父进程在之后执行wait()操作，来确定子进程是如何终止的。内核通过将子进程转化为僵尸进程来处理这种情况。子进程会释放大部分的内存，唯一保留的是，内核进程表中的一条记录。

   4. exec() 程序的执行

      将新程序加载到某一进程的内存。

      - 文件描述符和exec()
      - system()的实现

   5. 详述进程创建和程序执行

      - 进程记账 在进程终止时，写入一条记录信息
      - 系统调用clone()，也可以创建新的进程，对步骤的控制更加精准
      - exec()和fork()对进程属性的影响

#### 线程

##### 概述 包含线程的进程内存模型

- 相对多进程的优势
  1. 多进程数据段和代码段都不复用、内存不共享
  2. fork()来创建子进程的代价比较高

##### 互斥量

1. 加锁和解锁
2. 只有一个线程能够加锁，其他的会处于阻塞的状态

##### 条件变量

允许一个线程就某个共享变量的状态通知其他线程，并让其他线程等待（堵塞于）这一通知

1.  通知和等待条件变量。

   ```c++
   condition_variable notfull;
   condition_variable notempty;
   mutex lock;
   
   void deposit(int data){
       // 先获取共享变量的锁
       unique_lock<mutex> lk(lock);    
       while(deq.size() == capacity){
           // 当不满足生产条件是，会将这个线程放进 等待状态的线程池，在放进去之前会释放获得的锁
           // 当被唤醒后，依然会检查是否可以生产
           not_full.wait(lk);    
       }
       deq.push_back(data);
       lk.unlock();
       not_empty.notify_one();
   }
   
   notfull.wait(lk);
   notfull.
   ```

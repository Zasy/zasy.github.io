---
title: C++基础整理(1)
date: 2018-09-28 14:09:19
tags: c++
---

[TOC]

### 编程基础

1. 为什么会有C++，相对于C语言的升级在哪？
   - 添加了了面向对象编程
   - 继承了C语言高效、简洁、快速和可移植的特点。
   - 添加了泛型编程方法
2. C/C++语言的历史发展和必要性
3. 条件编译#ifdef, #else, #endif作用？
   - 通过#ifdef来判断，将某些具体的模块包括到要编译的内容 ，只判断之前是否有该宏定义
   - 子程序前加#define DEBUG 用于程序调试
   - 应对硬件的设置
   - 条件编译可以减少被编译的语句



### 编译和调试

#### 编译

##### 预处理

- 宏定义的替换 `#define`

- 条件编译语句过滤代码  `#ifdef`

- 处理#include指令，插入对应的文件到指令的位置 `#include`

- 过滤所有的注释的语句
- 添加行号和文件名标识
- 保留所有的#program编译器指令 `#program`

##### 编译

- 词法分析
  - 读取源程序的字符，生成词法单元序列
- 语法分析
- 语义分析
- 中间语言生成 汇编
- 目标代码生成与优化 二进制代码

##### 链接

 各个源代码模块独立的被编译，然后将他们组整起来，组装的过程就是链接。将所有目标文件的代码段拼接到一起，然后将所有对符号地址的引用加以修正。

- 静态链接

  在编译时和静态库(lib****.a)链接在一起成为完成的程序。通常静态库就是对多目标文件(.o)文件的打包。细节：静态链接被用到的目标文件都会复制到最终生成的可执行文件中。这种方式的好处是在运行时，可执行文件已尽装载完毕，速度比较快。

  静态文件是对多目标文件的打包，这里介绍些打包命令。

  ```shell
  gcc -c test1.c // 生成test1.c
  gcc -c test2.c // 生test2.c
  ar cr libtest.a test1.o test2.o
  ```

  在生成可执行文件需要使用到它的时候只需要在编译时加上即可。

  ```shell
  gcc -o main main.c -ltest
  ```

- 动态链接

  多个程序都需要某个静态库，在每个程序中都需要拷贝一份，所以出现动态链接来解决这个问题。

  首先打包成动态库，文件名为lib + 动态库名+ .so 后缀。编译时加上-fPIC选项，打包时加上-shared选项。

  ```shell
  gcc -fPIC -c test1.c
  gcc -fPIC -c test2.c
  gcc -shared test1.o test2.o libtest.so
  ```

  使用动态链接的用法和静态链接相同

  ```shell
  gcc -o main main.c -ltest
  ```

- 静态链接库和动态链接库的对比
  - 动态链接库运行时会先检查内存中是否存在该库的拷贝，若有则共享拷贝，标准模版库就是动态链接库。
  - 动态链接库的升级更新很容易
  - 静态链接库执行效率会比较高

- 静态联编和动态联编的区别

makefile编写

自动化编译的工具

- 基本规则

  ```shell
  A:B
  (tab)<command>
  ```

  A是语句最后生成的文件，B是生成A所依赖的文件，比如生成test.o依赖test.c 和 test.h, 则写成 test.o:test.c test.h。接下来一行的开头必须是tab ，再往下就是实际的命令, 比如 gcc.c -c test.c -o test.o 。

- 变量

  在文件中可以定义变量，在之后需要使用的时候只需要写一个$符号加上变量名即可。

- 自动寻找依赖

  第一条目标即为编译输出的目标，程序会依次寻找依赖的关系，当依赖不存在时，贼寻找下面的生成目标形成隐形的依赖生成

调试

符号解析

- 可重定位目标文件 (relocatable file)

  独立编译后的(.o)文件，其ELF文件格式包括：

  - ELF头，指定文件的大小及字节序
  - .text， 代码段
  - .rodata, 只读数据区
  - .data，已初始化数据区
  - .bss，未初始化数据区
  - .symtab，符号表

- 解析符号表

  - 将每个引用和文件中的符号表的一个符号定义联系起来

重定位

- 合并节

  多个可重定向目标文件中的相同的节合并成一个完整的聚合节，例如多个目标文件的.data节合并为可执行文件的.data节。

- 重定位符号引用

  修改全部代码节和数据节对每个符号的引用，执行正确的运行时地址。

##### 可执行目标文件

- ELF头部

  描述文件的总体格式，并且包括程序的入口点，即第一条指令地址

- 段头部表

  描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对其、执行权限等。通过段头部表描绘了虚拟存储器运行时存储映像，比如每个unix程序的代码段总从虚拟地址的Ox0804800开始。

- 其他段

  和可重定位目标文件相同，但是完成了多个节的合并和重定位的工作

##### 加载

- 克隆

  新程序的执行首先要父进程fork()得到一个子进程，该子进程除了pid等标识不同其他基本均与父进程相同。

- 重新映射

  当子进程执行自己的系统调用时，会先清空子进程现有的虚拟存储段(不再映射到父进程到各个段)，之后重新创建子进程虚拟存储器各段和可执行文件各段的映射。可理解为对复制进来的父进程页表进行重写，映射到外存中的各个段。

- 虚页调入

  加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得了指令的虚拟地址后，若该指令不再内存中，则从外存中调入。